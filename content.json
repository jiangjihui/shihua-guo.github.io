{"meta":{"title":"Alan","subtitle":null,"description":"alan's blog","author":"Alan","url":"http://haojen.github.io"},"pages":[{"title":"Tags","date":"2017-09-24T01:39:44.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"Tags/index.html","permalink":"http://haojen.github.io/Tags/index.html","excerpt":"","text":""}],"posts":[{"title":"arcgis绘制功能","slug":"arcgis-draw","date":"2018-06-28T11:47:59.000Z","updated":"2018-06-30T04:16:10.000Z","comments":true,"path":"2018/06/28/arcgis-draw/","link":"","permalink":"http://haojen.github.io/2018/06/28/arcgis-draw/","excerpt":"","text":"arcgis绘制功能 基于api 3.24 背景最近需要做一个地图小工具（测距、侧面积、缓冲区分析）的需求。客户说只要arcgis自带的工具就可以了。然而，项目的图层比较复杂，而且arcgis自带的工具几乎不能定制，所以我并有考虑直接使用自带的工具。所以我的思路如下： 使用arcgis javascript api 的Draw工具（ esri/toolbars/draw ），主要功能是绘制出点线面。 然后再计算绘制出来的图形，这里需要使用geometryEngine（ esri/geometry/geometryEngine 3.13才添加的新工具 ），主要功能是计算对应的图形长度面积等。这里也可以使用arcgis server里面的服务来代替。 下面说下实现的步骤： 使用Draw工具绘制图形（官网实例代码）。 new出draw工具—&gt;定义绘制完成的回调函数—&gt;在对应地方添加触发绘制的事件 引入对应的draw esri/toolbars/draw ，定义draw工具 var draw = new Draw(map); 定义绘制完成的回调函数 var draw = new Draw(map);/** on(type: \"draw-complete\", listener: (event: &#123; geometry: Geometry; target: Draw &#125;) =&gt; void): esri.Handle; 回调函数的参数有：绘制完成图形的对应的地理信息：geometry，以及整个draw对象。 */draw.on(\"draw-complete\",endDraw)function endDraw(event)&#123; //逻辑处理&#125; 在对应的dom触发对应的图形绘制，下面举例绘制点的例子。 var draw = new Draw(map);/** on(type: \"draw-complete\", listener: (event: &#123; geometry: Geometry; target: Draw &#125;) =&gt; void): esri.Handle; 回调函数的参数有：绘制完成图形的对应的地理信息：geometry，以及整个draw对象。 */draw.on(\"draw-complete\",endDraw)function endDraw(event)&#123; //逻辑处理&#125;var ptDom = document.getElementById(\"ptDom\")ptDom.addEventListener(\"click\", drawPoint, false); function drawPoint()&#123; this.draw.activate(Draw.POINT);&#125; 下面分别是开启绘制对应图形的代码，以及取消绘制，可以在对应的dom事件添加： function drawCircle()&#123;//绘制圆 this.draw.activate(Draw.CIRCLE);&#125;function drawPolygon()&#123;//绘制多边形 this.draw.activate(Draw.POLYGON);&#125;function drawPolyline()&#123;//绘制线 this.draw.activate(Draw.POLYLINE);&#125;function endDraw()&#123; this.draw.deactivate();&#125; 测距、测面积的工具实现。引入工具geometryEngine esri/geometry/geometryEngine工具，这里需要在绘制完成的回调参数里面判断绘制的图形类型，然后再做对应处理。下面关注 endDraw 函数即可。 function endDraw(event)&#123; //逻辑处理 var result = null; switch (event.geometry.type) &#123; case \"point\": break; case \"polyline\": //使用geodesicLength计算长度 result = GeometryEngine.geodesicLength(event.geometry,\"kilometers\"); break; case \"polygon\": //使用geodesicArea计算面积 result = GeometryEngine.geodesicArea(event.geometry,\"kilometers\"); break; default: break; &#125;&#125; 上面就能得到你需要的结果，然后再你想要的地方显示出来就可以了。 缓冲区分析工具实现。我们继续在回调函数 endDraw 处理。缓冲区分析，主要就是在绘制的范围内，筛选出该范围内的图形。主要是针对各种图层服务来做对应的处理。下面主要介绍：FeatureServer、以及featureCollection构建的FeatureLayer图层。 ...var layer //这里是你的各种图层...function endDraw(event)&#123; switch (event.geometry.type) &#123; case \"polygon\": //只有是多边形的才进行处理 switch (layer.type) &#123; case \"Feature Layer\": if(layer.url)&#123;//如果是基于arcgis server的服务的FeatureLayer /* 引入\"esri/tasks/query\"，可以直接调用服务的查询，非常方便 */ var query = new Query(); query.geometry = event.geometry; query.outFields = [\"OBJECTID\"]; var queryTask = new QueryTask(layer.layer.url); var queryTask.execute(query, (results: any) =&gt; &#123; //results就是在绘制范围内的要素。 &#125;); &#125;else&#123;//如果是基于featureCollection构建的FeatureLayer &#125; break; default: break; &#125; break; default: break; &#125;&#125;","categories":[],"tags":[]},{"title":"arcgis导出","slug":"arcgis-export","date":"2018-06-27T11:32:07.000Z","updated":"2018-06-30T05:17:05.000Z","comments":true,"path":"2018/06/27/arcgis-export/","link":"","permalink":"http://haojen.github.io/2018/06/27/arcgis-export/","excerpt":"","text":"arcgis导出 基于arcgis javascript api 3.24 背景最近需要做一个地图导出的需求。有大概一下2个要求： 需要导出全市范围（也就是包括视野范围之外的也需要导出） 所见即所得，当前页面看到的和导出的一致。 于是，我大致思路如下： 使用arcgis自带的PrintTask工具 直接将整个地图“截图”下来，保存成图片再给客户。 使用PrintTask使用PrintTask比较简单，官网也有例子。主要步骤如下： var printTask = new PrintTask(url); 这里的url放的是这个工具的服务地址。arcgis官网的工具地址。如果本地有arcserver，那么本地的地址可以到arcgisserver 后台管理查看,进入后台管理后，点击左边的 Utilities 然后看到 PrintingTools 就是了。 var params = new PrintParameters();建立导出的模板PrintParameters，具体参数去api查看。并且设置map： params.map = map; 执行：printTask.execute(params, printResult=&gt;{});这里会回调一个printResult，里面带有图片或者pdf等文件的下载地址。 注意：导出可能会遇到超时问题。 但是呢，我遇到了以下问题： 最严重的是，导出速度非常非常非常慢。经测试，最简单的导出需要3分钟左右。所以会遇到超时问题，这里需要设置一下esriConfig。代码如下： import esriConfig = require(\"esri/config\")...esriConfig.defaults.io.timeout = 300000;//这里设置你的超时时间 开始我以为是来源于PrintingTools服务的 客户端可使用服务的最长时间 设置造成的，其实并不是。是因为esri默认的请求时间是1分钟。 导出的分辨率低，而且不能识别某些图层。比如我使用featureSet构建的图层。 以上，PrintingTools导出的速度基本就判死刑了。经我们公司的arcgis人员使用arcserver导出也是非常慢。原因不得而知，cpu/内存占用几乎没变化，并且导出会提示内存不足，但是内存十分充足。 所以在这里请教一下大家，服务器并没有显卡,是因为gpu的问题吗，才导出这么慢吗？所以，我今天选择了第二种方法：截图。 截图保存 有了这个想法，我就查了如何实现，并且查到相关的：arcgis api for js入门开发系列二十打印地图的那些事。非常感谢！ 主要步骤如下： 获取到地图的容器-&gt;将图层元素转化为canvas-&gt;下载。 这里需要用到html2canvas。 实现很简单，代码如下，(完全从上面的简书搬过来的),我重点是解决上面简书并没有提及的一些问题： canvasPrint=function () &#123; var targetDom = $(\"#map\"); //克隆截图区域 var copyDom = targetDom.clone(); copyDom.width(targetDom.width() + \"px\"); copyDom.height(targetDom.height() + \"px\"); copyDom.attr(\"id\", \"copyDom\"); $(\"body\").append(copyDom); //移除不需要截图的区域 $(\".base-map\").remove(); var pathName = document.location.pathname; var ctxPath = pathName.substring(1, pathName.substr(1).indexOf('/') + 1); html2canvas(copyDom[0], &#123; useCORS: true, imageTimeout:0 //, proxy: \"/\" + ctxPath + \"/proxy/proxyScreenShot\" &#125;).then(function (canvas) &#123; var url = canvas.toDataURL(); //创建下载a标签 var a = document.createElement(\"a\"); a.setAttribute(\"id\", \"download\"); document.body.appendChild(a); //以下代码为下载此图片功能 var triggerDownload = $(\"#download\").attr(\"href\", url).attr(\"download\", \"img.png\"); triggerDownload[0].click(); //移除下载a标签 document.body.removeChild(a); //克隆DOM删除 copyDom.remove(); &#125;);&#125; 会出现以下问题 问题1：图层会和底图出现偏移，如图： 为什么会出现偏移呢？ 因为html2canvas转化成canvas的时候并不支持transform我们看看各个图层在dom是如何构成： viewDiv(定义的地图div)│└───viewDiv_root └───viewDiv_container └───viewDiv_layers(存放地图的div) 可以看到，在我们没有移动地图时，viewDiv_layers的transform都为0px；而这时候转化的canvas是并没有偏移的。但是，当我们拖动地图的时候，viewDiv_layers的transform开始变化。所以，html2canvas并没有将transform渲染上去。 我们可以在导出前重新加载地图，来去除偏移 因为代码结合了较多的业务，所以放代码也没有多大的意义，就放伪代码吧。个人也懒的重新写一个。 保存当前地图中心点位置以及缩放（就是拖动地图之后的中心点位置以及缩放） var center = this.map.extent.getCenter();var zoom = this.map.getZoom(); 使用上一次的中心点和缩放，重新new一遍地图。 const esriMap = new EsriMap(\"viewDiv\", &#123; center: center, zoom: zoom,&#125;); 这时候，就可以看到transform都变为0了。就可以放心导出了。 问题2：当文件过大，下载的时候会出现。失败,网络错误的提示。 这里有一个相关答案 这时候不用担心，不是代码有问题，也不是html2canvas问题。上面，我们是用base64来进行下载的，而谷歌浏览器限制了donwload属性的a标签url长度。这时候我们可以将html2canvas转化为blob，再使用一个插件： FileSaver进行下载 ，代码如下，只需要在返回canvas的代码块中修改一下就可以了： canvasPrint=function () &#123; var targetDom = $(\"#map\"); /* 克隆截图区域 */ var copyDom = targetDom.clone(); copyDom.width(targetDom.width() + \"px\"); copyDom.height(targetDom.height() + \"px\"); copyDom.attr(\"id\", \"copyDom\"); $(\"body\").append(copyDom); /* 移除不需要截图的区域 */ $(\".base-map\").remove(); var pathName = document.location.pathname; var ctxPath = pathName.substring(1, pathName.substr(1).indexOf('/') + 1); html2canvas(copyDom[0], &#123; useCORS: true, imageTimeout:0 /* , proxy: \"/\" + ctxPath + \"/proxy/proxyScreenShot\" */ &#125;).then(function (canvas) &#123; /* --------------修改部分----------------------- */ canvas.toBlob(function(blob) &#123; FileSaver.saveAs(blob, \"image.png\"); &#125;); /* --------------修改部分----------------------- */ /* 克隆DOM删除 */ copyDom.remove(); &#125;);&#125; 问题3：无法导出featureLayer的图层。如图，我们需要出现的房子并没有出现：为什么呢？我们再来看看各个图层在dom是如何构成：以上，可以看到要素图层是存放于svg里面，而每一个graphic都存放于image标签内。这样就构建成了一个要素图层。所以，这有什么关系呢？你可能需要更新一下html2canvas,因为从0.5.0-alpha1版本才开始支持svg渲染，而且html2canvas会忽略svg元素，不过只需要添加一下 allowTaint: true 属性就可以了。 canvasPrint=function () &#123; var targetDom = $(\"#map\"); /* 克隆截图区域 */ var copyDom = targetDom.clone(); copyDom.width(targetDom.width() + \"px\"); copyDom.height(targetDom.height() + \"px\"); copyDom.attr(\"id\", \"copyDom\"); $(\"body\").append(copyDom); /* 移除不需要截图的区域 */ $(\".base-map\").remove(); var pathName = document.location.pathname; var ctxPath = pathName.substring(1, pathName.substr(1).indexOf('/') + 1); html2canvas(copyDom[0], &#123; useCORS: true, imageTimeout:0, /* --------------修改部分----------------------- */ allowTaint: true /* --------------修改部分----------------------- */ /* , proxy: \"/\" + ctxPath + \"/proxy/proxyScreenShot\" */ &#125;).then(function (canvas) &#123; canvas.toBlob(function(blob) &#123; FileSaver.saveAs(blob, \"image.png\"); &#125;); /* 克隆DOM删除 */ copyDom.remove(); &#125;);&#125; 以上允许了渲染svg，如果没有意外，下载的时候会出现以下错误: Uncaught DOMException: Failed to execute &apos;toDataURL&apos; on &apos;HTMLCanvasElement&apos;: Tainted canvases may not be exported. 看html2canvas源码发现，貌似如果开启了支持svg，会执行以下代码。 var testSVG = function testSVG(document) &#123;var img = new Image();var canvas = document.createElement('canvas');var ctx = canvas.getContext('2d');img.src = 'data:image/svg+xml,&lt;svg xmlns=\\'http://www.w3.org/2000/svg\\'&gt;&lt;/svg&gt;';try &#123; ctx.drawImage(img, 0, 0); canvas.toDataURL();&#125; catch (e) &#123; return false;&#125; return true;&#125;; 就是将svg拿到然后drawImage将svg图片绘制进canvas。这里，如果new的img标签没有设置 crossOrigin 属性为 anonymous 那么谷歌浏览器会不允许执行canvas.toDataURL()和toBlob()方法。因为画布被污染了。 解决思路: 我觉可以将image标签添设置 crossOrigin 属性为 anonymous 就可以导出咯。但是这些都是arcgis生成的。我并没有试过。或者可以修改html2canvas的源码？不过，因为思维局限，我想到了另外一种方法：将svg部分转化为image-&gt;再将image写入到canvas 将svg部分转化为image，这里我用了saveSvgAsPng插件，再将image写入到canvas。 canvasPrint=function () &#123; var targetDom = $(\"#map\"); /* 克隆截图区域 */ var copyDom = targetDom.clone(); copyDom.width(targetDom.width() + \"px\"); copyDom.height(targetDom.height() + \"px\"); copyDom.attr(\"id\", \"copyDom\"); $(\"body\").append(copyDom); /* 移除不需要截图的区域 */ $(\".base-map\").remove(); /* --------------修改部分----------------------- */ /* 转换svg，找到对应的svg元素，再设置crossOrigin */ let dom = document.querySelector(\"#viewDiv_layers svg\"); let img = new Image(); saveSvgAsPng.svgAsDataUri(dom,&#123;&#125;, (uri:any)=&gt;&#123; img.src = uri; /* 这里是重点 */ img.setAttribute(\"crossOrigin\",'anonymous') &#125;); /* --------------修改部分----------------------- */ var pathName = document.location.pathname; var ctxPath = pathName.substring(1, pathName.substr(1).indexOf('/') + 1); html2canvas(copyDom[0], &#123; useCORS: true, imageTimeout:0, /* , proxy: \"/\" + ctxPath + \"/proxy/proxyScreenShot\" */ &#125;).then(function (canvas) &#123; /* --------------修改部分----------------------- */ let ctx = canvas.getContext(\"2d\") /* 对应的CanvasRenderingContext2D对象(画笔) */ ctx.drawImage(img,0,0); /* --------------修改部分----------------------- */ canvas.toBlob(function(blob) &#123; FileSaver.saveAs(blob, \"image.png\"); &#125;); /* 克隆DOM删除 */ copyDom.remove(); &#125;);&#125; 以上，就能解决了。 问题5：如何在地图放大之后，导出包括视野范围外的整张地图。大致步骤：导出前修改dom的宽度和高度-&gt;触发地图更新-&gt;导出导出前进行对地图dom的width和height进行调整。明确一下：每一次对地图的zoom，width和height都会*2，所以计算每次zoom是2的（zoom差值的次方）。 /* zoomOrigin(原始放大级别),zoomChange(当前放大级别)widthOrigin(原始放宽度)heightOrigin(原始高度)关系如下：width = widthOrigin * Math.pow(2,(zoomOrigin-zoomChange))height = heightOrigin * Math.pow(2,(zoomOrigin-zoomChange)) */var zoomOrigin;...var zoomChange = this.map.getZoom();var dom = document.getElementById(\"viewDiv\");dom.style.width = dom.style.width * Math.pow(2,(zoomOrigin-zoomChange))dom.style.width = dom.style.width * Math.pow(2,(zoomOrigin-zoomChange))/* dom发生变化之后地图会自动进行调整，这里由于宽度和高度是向右下扩展的， 所以，我们需要重新定位中心点，这里需要监听map的更新完成事件，再进行中心点调整 */...var center;/* 原来记录好的中心点*/var updateEvent = this.map.on(\"update-end\",function(event)&#123; this.map = new EsriMap(\"viewDiv\", &#123; center: center, zoom: zoomChange, &#125;); updateEvent.remove();/* 移除事件监听 */&#125;)...//之后进行导出即可 问题4：使用瓦片服务，会出现跨域问题。地图会空白,如图，左边为需要的效果，右边为实际效果。 一般都会有代理软件吧，所以其实只要把瓦片服务代理一下就可以了。用Apache或者Nginx等都可以。 总结总的来说，如果用“截图”的方式导出。需要使用html2canvas插件，然后再解决偏移、下载、要素图层无法渲染的问题即可。","categories":[],"tags":[]},{"title":"functional programming","slug":"functional-programming","date":"2018-03-26T14:02:21.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2018/03/26/functional-programming/","link":"","permalink":"http://haojen.github.io/2018/03/26/functional-programming/","excerpt":"","text":"Functional Programming 仅仅是一篇观后感 最近在我违反了 no mutation ，既在一个函数里面修改了传入的变量。导致我在另外一个地方使用该变量的时候，并不知道它已经发生了变化。然后，我突然想起了好几个月前看得一个演讲:Anjana Vakil: Learning Functional Programming with JavaScript - JSUnconf 2016。这里面就有讲什么是 Functional Programming。我发现，在JS中，遵循了下面几条原则，可以更好的复用、维护代码。 在平时写业务的过程中设计模式是谈不上了，但是Functional Programming恰处处可见。 What is Functional Programming?什么是Functional ProgrammingA programming paradigm.一种编程的范式。就像面向过程、面向对象（狗.吃(屎)）。总的来说，Function is King 如果说面向过程就类似于（吃(狗,屎)）、面向对象类似于（狗.吃(屎)），那么Functional Programming可以初略概括为：狗.吃(屎) -&gt; 屎，因为只有input和output才算是一个合格的function。 A code style.一种代码的风格。如何去组织你的代码。 A mindset.一种思维模式。该使用什么样的方式去解决你的问题？就像你不想去破解一个代码块完整性（内聚），那么你可以加入一个切面，去影响该代码块的执行结果。 A sexy, buzz-wordy trend. Why Functional Javascript?Object-oriented in javascript gets tricky.因为在JavaScript中，面向对象往往纠缠不清。就比如this.貌似真的很多时候，this的指向会变化多端。 Safer, easier to debug/maintain. Established community. How Functional Programming in Javascript?Do everything in function.非常简单，就是一个input-&gt;output的过程。你只需要简单的把input交给一个function处理，然后它会给你需要的output。就像一种数据的流向。有以下的 以下是非Functional的形式（A）：var name = &quot;Alan&quot;;var greeting = &quot;Hi,I&apos;m &quot;;console.log(greeting+name);=&gt; &quot;Hi,I&apos;m Alan&quot; 以下是Functional的形式（B）：function greet(name)&#123; return &quot;Hi,I&apos;m &quot;+name;&#125;greet(&quot;alan&quot;);=&gt; &quot;Hi,I&apos;m Alan&quot; 例子A中，处理形式就是定义完greet，然后定义name，然后一起输出。而例子B，是将name交给一个greet函数处理，它会返回拼接一个greet然后返回给你。 Use pure function.在Functional Programming中，我们会遇到一个问题：function a中，改变了input的内容，然后你在其他的function b中使用该input的时候，发现它已经被改变，然后也许function b中的执行结果会因为function a中改变了input而改变。这个就是文章开头提及的情况。这时候，你可能会绞尽脑汁，究竟在哪里改变了它。所以，纯净的function是不应该去改变input的。你应该在一个function里面拿了input，然后只读取input然后计算output，然后把output返回。var name = &quot;alan&quot;;function greet()&#123; name = &quot;jade&quot;; return &quot;Hi,I&apos;m &quot;+name;&#125;function sayMyName(name)&#123; return &quot;Hi,I&apos;m &quot;+name;&#125;greet();sayMyName(name); 同样，以下也不是纯净的functionvar name = &quot;alan&quot;;function greet()&#123; console.log(&quot;Hi,I&apos;m &quot;+name);&#125; 并没有input,直接使用了全局的变量。而且并没有返回计算的结果，我们需要的是function帮我们计算并返回结果，打印并不是function需要做的事情。正确做法应该如下,function唯一需要做的就是使用input去计算得出我们需要的output，并将output返回：var name = &quot;alan&quot;;function greet(name)&#123; return &quot;Hi,I&apos;m &quot;+name;&#125;","categories":[],"tags":[]},{"title":"使用七牛chrome插件上传图片","slug":"使用七牛chrome插件上传图片","date":"2018-03-22T15:24:55.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2018/03/22/使用七牛chrome插件上传图片/","link":"","permalink":"http://haojen.github.io/2018/03/22/使用七牛chrome插件上传图片/","excerpt":"","text":"下载插件qiniu upload files 打开插件，进行配置插件的设置 分别对应自己的用户中的以下设置。","categories":[],"tags":[]},{"title":"vue状态的不同引用方式引发表单验证","slug":"vue状态的不同引用方式引发表单验证","date":"2018-03-22T15:15:32.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2018/03/22/vue状态的不同引用方式引发表单验证/","link":"","permalink":"http://haojen.github.io/2018/03/22/vue状态的不同引用方式引发表单验证/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"2个组件之间实现同步Vue","slug":"sync-in-components","date":"2017-11-27T15:05:40.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2017/11/27/sync-in-components/","link":"","permalink":"http://haojen.github.io/2017/11/27/sync-in-components/","excerpt":"","text":"需求：组件1为组件2的子组件，组件1的A方法需要与组件2的B方法同步。使用$emit进行通知。在组件1中调用save方法前，需要接受组件2的beforeSave方法传回的参数。可以在组件1中使用创建beforeSave通知组件2执行beforeSave方法，然后当组件2执行完beforeSave之后回调，再使用$emit通知子组件执行save方法 ####组件2中的组件1，&lt;component :ref=&quot;id&quot; @beforeSave=&quot;beforeSave&quot;&gt; &lt;component&gt;methods:&#123; beforeSave(&#123;entity,formName,isClear&#125;)&#123; axios.get(&apos;/api/getForeignKey&apos;).then(function(resp)&#123; let foreignKey = resp.data.foreignKey this.$refs[&apos;id&apos;].$emit(&apos;save&apos;,foreignKey); &#125;).catch(function(error)&#123; console.log(error) &#125;) &#125;&#125; ####组件1通知组件2beforeSave(entity,formName,isClear)&#123; this.$emit(&apos;beforeSave&apos;,&#123;entity,formName,isClear&#125;)&#125;,save(foreignKey)&#123; console.log(foreignKey)&#125;","categories":[],"tags":[]},{"title":"使用nexus建立个人npm库","slug":"nexus","date":"2017-11-13T15:05:04.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2017/11/13/nexus/","link":"","permalink":"http://haojen.github.io/2017/11/13/nexus/","excerpt":"","text":"下面分享一下如何使用nexus建立自己的npm仓库 准备工作 java环境 node环境 nexus安装包 3.6.0 运行nexus 进入解压后nexus的bin文件夹，在此目录打开cmd （使用gitbash执行可能会有问题）。执行nexus /run 默认端口为：8081，打开可以看到nexus界面了。 点击右上角可以登录，默认账号密码：admin admin123 “箱子”图标就是代表着仓库中的包，”齿轮”图标则为设置，下面我们进入设置 之后，我们将关注“Repository”和“Security”栏目。分别用于创建/管理仓库和用户 创建npm需要的Blob存储（此步骤可以忽略） 分别创建name为”npm-proxy”,”npm-hosted”,”npm-group”的存储（分别用于存放npm代理下载的依赖包、发布的私有依赖包、代理下载的和私有的组合的依赖包）。 创建npm仓库 点击“Create Repository” nexus增加了许多仓库类型，下面我们只关注和npm相关的 下面说下这几种类型的区别 hosted 为私有的仓库，我们在本地写好的npm插件就是发布到这个地方的。这个就是我们搭建私有仓库的目的。 proxy 为代理的镜像地址（我们一般设置为淘宝镜像即可），大概可以理解为，nexus帮我们从这个地址下载其他的npm依赖包。而且会自动缓存到nexus仓库。 group 用于私有仓库和代理仓库的组合。就是我们可以从group下载到私有的依赖（存放在nexus仓库的）和npm官网的依赖。 需要注意的是，hosted仅用于发布你的私有依赖，所以，如果你从hosted下载依赖是无法下载的。下载只能通过group下载。 下面开始建立仓库 创建代理仓库（npm-proxy） name为“npm-proxy” remote storage为“https://registry.npm.taobao.org“ 存储为“npm-proxy” 创建私有仓库（npm-hosted） name为“npm-hosted” 存储为“npm-hosted” 创建组个仓库（npm-group） name为“npm-group” 存储为“npm-group” 然后在group中，把前面2个创建的拖到右边框中 以上，仓库已经创建完成。可以通过界面进入仓库，查看刚刚创建的仓库。也可以直接访问，如果出现404，则说明name写错咯。地址和name对应的 http://localhost:8081/repository/npm-proxy/ http://localhost:8081/repository/npm-hosted/ http://localhost:8081/repository/npm-group/ 创建用户 之后我们发布需要这个用户登录 同时把npm Bearer Token Realm置于active 测试下载依赖包 切换npm的registry。可以运行一下命令。记住是npm-group 这个地址。 npm config set registry http://localhost:8081/repository/npm-group/ 同样的，我们也可以打开一下这个文件修改设置 C:\\Users\\你的用户名\\.npmrc 推荐设置（可以解决phantomjs、chromedriver、node-sass无法下载的问题）。直接把一下拷贝进.npmrc文件即可 loglevel=infoscripts-prepend-node-path=trueregistry=http://localhost:8081/repository/npm-group/chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriverphantomjs_cdnurl=http://cnpmjs.org/downloadssass_binary_site=https://npm.taobao.org/mirrors/node-sass/ 设置完之后，我们可以随便下载一个依赖，看是否是经过nexus下载的。 npm install -g generator-vuejs 可以看到的确是走npm-group仓库的。这时候去nexus库查看，可以看到，nexus把从淘宝下载的镜像都缓存在本地了。 测试发布 切换成npm-hosted 的地址 npm config set registry http://localhost:8081/repository/npm-hosted 登录，运行以下命令，然后输入刚刚创建的用户名和密码即可 npm adduser 找一个需要发布的依赖，在根目录运行以下命令，设置registry为npm-hosted，并发布 npm publish 200即为发布成功去nexus仓库可以看到刚刚发布的依赖包","categories":[],"tags":[]},{"title":"用状态驱动应用","slug":"state-of-vue","date":"2017-10-28T15:27:08.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2017/10/28/state-of-vue/","link":"","permalink":"http://haojen.github.io/2017/10/28/state-of-vue/","excerpt":"","text":"状态的必要性 当组件A逐渐变得庞大，需要从组件A中抽取模块变成组件B，或者需要引入更多的组件时，如果通过props来进行组件之间的通信，那么会变得困难，特别是需要依赖更多其他组件的属性时，而且此时，组件间的耦合度会变大，而且对于通信内容都是单向的（通过on可以实现双向，但是比较麻烦）。这时候，组件间的通信都使用状态来管理，那么可以降低耦合度，而且能够响应，并实时更新视图。","categories":[],"tags":[]},{"title":"使用vue开发如何解决跨域以及验证问题","slug":"CROS","date":"2017-09-29T15:29:11.000Z","updated":"2018-06-30T04:16:10.000Z","comments":true,"path":"2017/09/29/CROS/","link":"","permalink":"http://haojen.github.io/2017/09/29/CROS/","excerpt":"","text":"开代理就可以了。","categories":[],"tags":[]},{"title":"Java开发者常用工具","slug":"java-developer-kit","date":"2017-09-23T15:29:44.000Z","updated":"2018-04-20T15:59:54.000Z","comments":true,"path":"2017/09/23/java-developer-kit/","link":"","permalink":"http://haojen.github.io/2017/09/23/java-developer-kit/","excerpt":"","text":"重装系统是一件非常麻烦的事情，特别是继续再次搭建环境，每次需要用到的时候才会想到：“oh！我需要这个工具！”。下面给大家汇总一下一个java程序员所需要的一些工具，以备不时之需： 环境篇 Java环境官网地址，截止2017年9月25日 最新的版本(登录后下载)： jdk-5u22 jdk-6u45 jdk-7u80 jdk-8u144 为了方便使用windows的程序员快速切换各个版本的JDK，JDK6~8的exe都做成了zip并上传到百度云，这个可以直接修改环境变量就可以快速切换了：百度云地址提取密码：shvy Tomcat包含以下版本 tomcat-7.0.82 tomcat-8.5.23 tomcat-9.0.1(beta) 百度云地址提取密码：m3d3","categories":[],"tags":[]}]}